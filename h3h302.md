# Final Summary

## File descriptor

--> Dalam UNIX terdapat istilah "semua adalah file", hal ini dikarenakan dalam sistem UNIX hampir 
semua sumber daya berbentuk file hal ini termasuk pipes,console,driver,dan file itu sendiri 

--> File descriptor adalah lapisan dalam filesystem yang membuat bagian2 diatas menjadi sama 

--> Deskripsi file descriptor : file descriptor adalah angka intger sederhana yang mewakilkan 
objek di tingkat kernel yang dimana proses dapat membaca dan memnulis ke dalam objek tersebut.

--> file descriptor itu sendiri berbentuk indeks yang akan menunjukkan ke lokasi file descriptor 
table (fdtable).

--> Seperti yang di referensikan di chapter 0, kernel xv6 menggunakan file descriptor sebagai 
indeks untuk tiap process table. Hal diatas mengakibatkan tiap proses memiliki ruang khusus 
untuk tiap2 file descriptor yang dimulai dari 0.

--> kernel xv6 menggunakan aturan file descriptor UNIX standar dengan 3 integer yaitu, 
    - 0 untuk standard input 
    - 1 untuk standard output 
    - 2 untuk standard error

--> syscall read dan write digunakan untuk menulis dan membaca bytes dari file2 yang ditunjukan
oleh file descriptor

--> setiap file yang terbuka di wakilkan oleh struct file (lihat file.c)

--> struct file hanyalah wrapper yang membungkus inode dan pipe ditambah i/o offset, hal ini 
di tunjukkan di struct file tersebut dimana isi dari struct filenya hanyalah pointer yang ke 
struct pipe dan inode, ditambah nomor reference

```c
struct file {
  enum { FD_NONE, FD_PIPE, FD_INODE } type;
  int ref; // reference count
  char readable; // check if open file writable
  char writable; // check if open file can be read
  struct pipe *pipe; // pointer to pipe structure
  struct inode *ip; // pointer to inode structure
  uint off;
};
```

--> setiap syscall open() dipanggil oleh sebuah proses, akan terbuat struct file baru yang
mewakilkan dari file yang dibuka dengan identitas prosesnya 

--> bila satu file dibuka oleh beberapa proses secara bersamaan maka tiap2 struct file akan 
dibedakan oleh i/o offsetnya yang berbeda di tiap proses

--> Terdapat anomali lain dalam file descriptor dimana suatu struct file dapat ditemukan di
beberapa tabel proses yang berbeda, hal ini diakibatkan bila suatu proses menggunakan syscall 
open untuk membuka file lalu proses tersebut mwmbuat duplikat menggunakan dup atau membagi struct
tersebut dengan child prosesnya menggunakan fork()

--> dalam struct file terdapat variable ref (int ref;) reference merupakan variable yang 
menghitung jumlah references terhadap file yang terbuka

--> Read dan write merupakan variable yang mendeteksi apakah file yang terbuka tersebut dapat di
baca ataupun ditulis

--> semua file yang terbuka di sistem disimpan di global file table (ftable) dalam ftable 
terdapat 3 function yaitu, 
      - filealloc
      - filedup
      - fileclose
      - fileread
      - filewrite

--> filealloc merupakan function yang berguna untuk mengalokasikan suatu file yang terbuka untuk
suatu proses

--> cara kerja filealloc adalah pertama men-scan tabel untuk file2 yang tidak direferensikan dan
me-return references baru

```c
struct file*
filealloc(void)
{
  struct file *f;

  acquire(&ftable.lock);
  for(f = ftable.file; f < ftable.file + NFILE; f++){
    if(f->ref == 0){ // filealloc mengecek tabel apakah ada file yg belun di-referensikan
      f->ref = 1;
      release(&ftable.lock);
      return f; // filealloc me-return reference baru
    }
  }
  release(&ftable.lock);
  return 0;
}
```

--> filedup merupakan function untuk menduplikasikan reference dari suatu file yang terbuka

--> filedup menggunakan konsep yang sama dengan filealloc, yang bedanya adalah referencenya di
increment (ditambahkan) tiap me-return reference yang baru

```c
struct file*
filedup(struct file *f)
{
  acquire(&ftable.lock);
  if(f->ref < 1)
    panic("filedup");
  f->ref++;
  release(&ftable.lock);
  return f;
}
```

--> fileclose merupakan function yang melepaskan reference count dari open file tersebut,
otomatis menutup struct tersebut

--> di fileclose sebelum mereturn reference baru, reference tersebut di-decremented terlebih 
dahulu, dan bila reference tersebut sudah mencapai 0 maka fungsi fileclose akan melepas pipe
atau inode dari struct tersebut sesuai dengan tipe struct tersebut.

--> fileread merupakan function yang berfungsi untuk membaca data dari file yang
terbuka tesebut

--> filewrite mirip dengan fileread dengan perbedaan fungsinya adalah menulis pada file terbuka

--> cara kerja dua function tersebut adalah dengan pertama mengecek apakah operasi tersebut
dapat dilakukan di file yang terbuka atau tidak, lau syscall akan di-pass melalui pipe atau 
inode. bila file tersebut merupakan inode itu sendiri maka function akan menggunakan i/o offset
sebagai pengganti inode sebagai passing dari syscall tersebut. sedangkan pipes tidak memiliki 
konsep offset

--> syscall yang berkaitan dengan filesystem disimpan di sysfile.c

--> terdapat beberapa syscall di dalam sysfile yaitu,
      - sys_link
      - sys_unlink
      - sys_open
      - sys_mkdir
      - sys_mknod

--> sys_link dan unlink berfungsi untuk mengganti, membuat, ataupun menghapus reference kepada
inodes

--> kedua syscall diatas menggunakan proses transactions agar berhasil. 

--> cara kerja sys_link adalah pertama dengan me-fetching agrumen yang diperlukan di function
2 string yang satu baru dan yang satu lama (mewakilkan reference) jika reference lama ada dan 
bukan merupakan direktori sys_link akan men-increment jumlah ip>nlink nya. Setelah itu sys_link
akan memanggil function nameinparent untuk mencari direktori lamanya dan elemen final dari
reference yang baru. Setelah itu sys_link akan membuat entry bagi direktori baru di inode lama.
pada tahap ini direktori parent yang baru harus sudah ada dan berada di tempat yang sama dengan 
inode yang sudah ada. bila terdapat error pada proses ini maka sys_link harus kembali dan
me-decrement ip>nlink

--> transactions dapat membuat proses lebih aman dikarenakan, memperbaharui disk block proses 
tidak perlu memerhatikan urutan dalam melakukanna. tanpa transactions bila dalam urutannny salah
maka proses akan menjadi error

--> pada inode yang sudah ada, sys_link akan memberikan nama baru, sedangkan function create 
membuat nama baru untuk inode yang baru. 

--> function create merupakan generalisasi dari 3 syscall yang berkaitan dengan pembuatan file 
baru, 
      - bagian O_CREATE membuat file biasa baru
      - mkdir membuat direktori baru
      - mkdev membuat file perangkat baru

--> seperti sys_link, create dimulai dengan memanggil nameinparent untuk mendapatkan inode dari 
parent directory nya. lalu function akan memanggil memanggil dirlookup() untuk mengecek apakah 
nama yang di-input sudah ada atau belum, bila nama tersebut sudah ada maka perilaku create akan
tergantung pada function apa create berada, dimana open memiliki semantik yang berbeda dengan 
mkdir maupun mkdev. bila create digunakan pada open dan nama tersebut sudah ada dalam bentuk 
file biasa maka open akan menganggap proses tersebut berhasil dan file tersebut akan terbentuk.












